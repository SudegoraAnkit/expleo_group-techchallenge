/*
 * generated by Xtext 2.38.0
 */
package org.expleo.sarch.dsl.validation;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.xtext.validation.Check;
import org.expleo.sarch.dsl.softwareArchitectureDsl.Architecture;
import org.expleo.sarch.dsl.softwareArchitectureDsl.Component;
import org.expleo.sarch.dsl.softwareArchitectureDsl.Interface;
import org.expleo.sarch.dsl.softwareArchitectureDsl.PPort;
import org.expleo.sarch.dsl.softwareArchitectureDsl.Port;
import org.expleo.sarch.dsl.softwareArchitectureDsl.RPort;
import org.expleo.sarch.dsl.softwareArchitectureDsl.SoftwareArchitectureDslPackage;
import org.eclipse.emf.ecore.EObject; // <-- Import EObject

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SoftwareArchitectureDslValidator extends AbstractSoftwareArchitectureDslValidator {

    public static final String DUPLICATE_COMPONENT_NAME = "org.expleo.sarch.dsl.DuplicateComponentName";
    public static final String UNRESOLVED_INTERFACE = "org.expleo.sarch.dsl.UnresolvedInterface";
    public static final String DUPLICATE_PROVIDED_INTERFACE = "org.expleo.sarch.dsl.DuplicateProvidedInterface";
    public static final String DUPLICATE_REQUIRED_INTERFACE = "org.expleo.sarch.dsl.DuplicateRequiredInterface";
    public static final String PROVIDES_AND_REQUIRES_SAME_INTERFACE = "org.expleo.sarch.dsl.ProvidesAndRequiresSameInterface";
    public static final String UNFULFILLED_REQUIREMENT = "org.expleo.sarch.dsl.UnfulfilledRequirement";


    @Check
    public void checkComponentNameIsUnique(Architecture architecture) {
        Set<String> componentNames = new HashSet<>();
        List<Component> components = architecture.getElements().stream()
                                                     .filter(e -> e instanceof Component)
                                                     .map(e -> (Component) e)
                                                     .collect(Collectors.toList());

        for (Component component : components) {
            if (!componentNames.add(component.getName())) {
                error("Duplicate component name: '" + component.getName() + "'",
                      component,
                      SoftwareArchitectureDslPackage.Literals.ARCHITECTURE_ELEMENT__NAME,
                      DUPLICATE_COMPONENT_NAME);
            }
        }
    }

    @Check
    public void checkPortReferencesExistingInterface(Port port) {
        // The Xtext linker usually handles this for cross-references.
        // This explicit check provides a more specific message if resolution fails.
        if (port.getInterface() == null) {
            error("Port references an unknown interface.",
                  port,
                  SoftwareArchitectureDslPackage.Literals.PORT__INTERFACE,
                  UNRESOLVED_INTERFACE);
        }
    }

    /**
     * Checks that a component does not provide the same interface multiple times,
     * and does not require the same interface multiple times.
     */
    @Check
    public void checkComponentPortInterfaceUniqueness(Component component) {
        Set<String> providedInterfaces = new HashSet<>();
        Set<String> requiredInterfaces = new HashSet<>();

        for (Port port : component.getPorts()) {
            Interface referencedInterface = port.getInterface();

            // Only proceed with semantic checks if the interface reference was successfully resolved by Xtext
            if (referencedInterface != null) {
                String interfaceName = referencedInterface.getName();

                if (port instanceof PPort) {
                    // Check for duplicate provided interfaces within this component
                    if (!providedInterfaces.add(interfaceName)) {
                        error("Component '" + component.getName() + "' provides interface '" + interfaceName + "' multiple times.",
                              port, // Attach error to the specific port that causes the duplication
                              SoftwareArchitectureDslPackage.Literals.PORT__INTERFACE, // Specific feature for highlighting
                              DUPLICATE_PROVIDED_INTERFACE);
                    }
                } else if (port instanceof RPort) {
                    // Check for duplicate required interfaces within this component
                    if (!requiredInterfaces.add(interfaceName)) {
                        error("Component '" + component.getName() + "' requires interface '" + interfaceName + "' multiple times.",
                              port, // Attach error to the specific port that causes the duplication
                              SoftwareArchitectureDslPackage.Literals.PORT__INTERFACE, // Specific feature for highlighting
                              DUPLICATE_REQUIRED_INTERFACE);
                    }
                }
            }
        }

        // Optional: Add a check if a component provides AND requires the same interface
        Set<String> commonInterfaces = new HashSet<>(providedInterfaces);
        commonInterfaces.retainAll(requiredInterfaces); // Intersection of the two sets

        if (!commonInterfaces.isEmpty()) {
            for (String commonIface : commonInterfaces) {
                // Find a port that both provides and requires this interface to attach the error
                // Declare the variable as EObject to accommodate both Port and Component
                EObject violatingObject = component.getPorts().stream()
                                        .filter(p -> p.getInterface() != null && p.getInterface().getName().equals(commonIface))
                                        .findFirst() // This returns Optional<Port>
                                        .orElse(null); // If no Port is found, this will be null

                // If no specific port was found, attach the error to the component itself.
                if (violatingObject == null) {
                    violatingObject = component;
                }

                error("Component '" + component.getName() + "' both provides and requires interface '" + commonIface + "'.",
                      violatingObject, // Pass the EObject variable here
                      null, // No specific feature for this high-level semantic error
                      PROVIDES_AND_REQUIRES_SAME_INTERFACE);
            }
        }
    }
    
    @Check
    public void checkRequiredInterfacesAreProvided(Architecture architecture) {
        Set<String> allProvidedInterfaceNames = new HashSet<>();
        // Collect all interfaces that are 'provided' by any component in the architecture
        for (EObject element : architecture.getElements()) {
            if (element instanceof Component) {
                Component component = (Component) element;
                for (Port port : component.getPorts()) {
                    if (port instanceof PPort && port.getInterface() != null) {
                        allProvidedInterfaceNames.add(port.getInterface().getName());
                    }
                }
            }
        }

        // Now, check every 'required' interface
        for (EObject element : architecture.getElements()) {
            if (element instanceof Component) {
                Component component = (Component) element;
                for (Port port : component.getPorts()) {
                    if (port instanceof RPort && port.getInterface() != null) {
                        String requiredInterfaceName = port.getInterface().getName();
                        // If a required interface is NOT found in the set of all provided interfaces, it's an error
                        if (!allProvidedInterfaceNames.contains(requiredInterfaceName)) {
                            error("Required interface '" + requiredInterfaceName + "' by component '" + component.getName() + "' is not provided by any component in the architecture.",
                                  port, // Attach error to the specific RPort
                                  SoftwareArchitectureDslPackage.Literals.PORT__INTERFACE, // Highlight the 'interface' feature of the RPort
                                  UNFULFILLED_REQUIREMENT);
                        }
                    }
                }
            }
        }
    }

}